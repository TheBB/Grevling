{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Grevling","text":"<p>Grevling (meaning \"badger\" in Norwegian) is a highly configurable tool for</p> <ul> <li>running parametrized jobs,</li> <li>collecting outputs from these jobs,</li> <li>storing relevant results in a database, and</li> <li>querying and reporting based on the database.</li> </ul> <p>Grevling is both a command-line tool as well as a Python library that provides an API to all the above.</p>"},{"location":"#overview","title":"Overview","text":"<p>A Grevling case is defined by a configuration file, written in the Gold language. Gold is a programmable configuration lanaguage created explicitly for use with Grevling. This configuration file is usually named <code>grevling.gold</code> and it defines, among other things:</p> <ul> <li>the parameters relevant to your case, their types and valid ranges,</li> <li>how to set up an instance of your job in an isolated environment,</li> <li>how to run the job, and</li> <li>which results to collect and how to interpret them.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Grevling configuration is written in the Gold language. This is a programmable configuration language, meaning that it supports conventional programming language features such as defining functions, sharing and importing data to and from other files, and so on. In this context, a <code>grevling.gold</code> file is a program whose output is a JSON-like object, which is the actual configuration read by Grevling.</p>"},{"location":"configuration/#specifying-the-parameter-space","title":"Specifying the parameter space","text":"<p>Grevling runs parametrized jobs, so it must know what the parameters are for each job that it runs. The <code>parameters</code> key, if present, maps names of parameters to lists of possible values, like so:</p> <pre><code>{\n    parameters: {\n        degree: [1, 2, 3, 4, 5, 6],\n        meshsize: [1, 0.5, 0.25, 0.0125],\n        adaptive: [true, false],\n    },\n}\n</code></pre> <p>This will run the job 48 times in total, once for each combination of <code>degree</code>, <code>meshsize</code> and <code>adaptive</code>.</p> <p>Grevling has functions that help facilitate some common use cases. They can be imported from the <code>\"grevling\"</code> library - a library that is available for import when running with Grevling. This is equivalent to the above:</p> <pre><code>import \"grevling\" as g\n\n{\n    parameters: {\n        degree: g.linspace(1, 6, npts: 6),\n        meshsize: g.gradspace(1, 0.0125, npts: 4, grading: 0.5),\n        adaptive: [true, false],\n    }\n}\n</code></pre> <p>The function <code>linspace</code> creates a uniform sampling of an interval with the given number of points. The function <code>gradspace</code> creates a geometric sampling that is denser in one end than in the other. Each successive subdivision is longer or shorter than the previous by the factor indicated by <code>grading</code>.</p>"},{"location":"configuration/#preparing-a-job","title":"Preparing a job","text":"<p>Grevling runs each instance of a job in a temporary directory. Often this directory must be prepared before the job runs by copying some files from the source directory (the directory where the configuration file is located). This can be configured using the <code>prefiles</code> key, which should be a list of files to copy. We recommend using the <code>copy</code> function to construct this list.</p> <pre><code>import \"grevling\" as { copy }\n\n{\n    prefiles: [\n        copy(\"some-file.txt\"),\n        copy(\"some-other-file.txt\"),\n    ]\n}\n</code></pre> <p>The files will then be copied into the working directory before the job runs. The name of the file in the working directory will be identical to its name in the source directory, but the name (and location) can be changed with an optional second argument:</p> <pre><code>import \"grevling\" as { copy }\n\n{\n    prefiles: [\n        copy(\"some-file.txt\", \"subpath/somewhere-else.txt\"),\n    ]\n}\n</code></pre> <p>Grevling also supports globbing: copying multiple files at once. For this, use the <code>glob</code> function.</p> <pre><code>import \"grevling\" as { glob }\n\n{\n    prefiles: [\n        glob(\"*.jpg\", \"images/\"),\n    ],\n}\n</code></pre> <p>In the above example, all jpg files will be copied into the images subdirectory in the working directory. Beware that all files will retain their original relative path to the target. In the following example, the files will end up in <code>images/subpath/...</code>.</p> <pre><code>import \"grevling\" as { glob }\n\n{\n    prefiles: [\n        glob(\"subpath/*.jpg\", \"images/\"),\n    ],\n}\n</code></pre> <p>Often, files will need to be modified in some way according to the values of the parameters. For this, Grevling uses template substitution with the Mako library. To enable template substitution, set the optional <code>template</code> keyword argument to <code>true</code>.</p> <pre><code>import \"grevling\" as { copy }\n\n{\n    prefiles: [\n        copy(\"input.ini\", template: true),\n    ]\n}\n</code></pre> <p>Please refer to the Mako documentation for more help on writing Mako templates. The values of all parameters will be available to the template when rendering, as well as the output of the <code>evaluate</code> function, if present (see extra evalution).</p> <p>TODO: Glob</p>"},{"location":"configuration/#running-a-job","title":"Running a job","text":"<p>The <code>script</code> key indicates how to run a job after it has been prepared. It is a list of commands. We recommend using the <code>cmd</code> function to construct this list.</p> <pre><code>import \"grevling\" as { cmd }\n\n{\n    script: [\n        cmd(\"some-program --args ...\"),\n        cmd(\"some-other-program --more-args ...\"),\n    ]\n}\n</code></pre> <p>Grevling will the execute each command in sequence, aborting immediately if one of them fails.</p> <p>Grevling also supports running a command as a list of arguments (the first element being the command to run, the subsequent elements being the arguments). This option is more foolproof against accidental shell quoting trouble, and is generally recommended - although somewhat more verbose.</p> <pre><code>import \"grevling\" as { cmd }\n\n{\n    script: [\n        cmd([\"some-program\", \"--args\", ...]),\n        cmd([\"some-other-program\", \"--more-args\", ...]),\n    ]\n}\n</code></pre> <p>The <code>cmd</code> function takes many optional parameters:</p> <pre><code>cmd(\n    command;\n    name = null,\n    env = {},\n    container = null,\n    container_args = [],\n    allow_failure = false,\n    retry_on_fail = false,\n    capture = [],\n    workdir = null,\n)\n</code></pre> <ul> <li>name: To access information about command output after a job has run, it is   necessary for each command to have its own uniuqe name. If this is not   provided, Grevling will attempt to deduce the name from the command   parameter, but it may be difficult or impossible to do so in certain   circumstances. For best results, always name your commands.</li> <li>env: Environment variables that will be used to augment the environment of   the command when it runs.</li> <li>container and container_args: See TODO.</li> <li>allow_failure: If this option is enabled, Grevling will not abort the job if   this command fails.</li> <li>retry_on_fail: If this option is enabled, Grevling will re-run the command   if it fails. Note that this continues indefinitely if the command continues   to fail.</li> <li>capture: Specifications for capturing output from the command's stdout   stream. TODO.</li> <li>workdir: Use this option to allow the command to run in a different working   directory. This path is NOT relative to the actual working directory!</li> </ul>"},{"location":"configuration/#collecting-output","title":"Collecting output","text":"<p>After a job isntance has finished successfully, Grevling copies some information back from the working directory to its own internal database (conventionally located in the <code>.grevlingdata</code> subdirectory wherever the configuration file is located). By default, Grevling copies the stdout and stderr stream from each command, as well as some metadata from the job instance in question. However, often you'd like to collect more data. For this, use the <code>postfiles</code> key. It works identically to the <code>prefiles</code> key (see preparing a job), except it does not support templates.</p> <p>Use this to collect output files that you are interested in keeping.</p> <p>Note that files declared in <code>prefiles</code> will not automatically be copied back after the job instance is finished. If you want to keep those files, e.g. to check whether template substitution was successful, those files must be copied explicitly in <code>postfiles</code> as well.</p> <pre><code>import \"grevling\" as { copy }\n\n{\n    postfiles: [\n        copy(\"some-output.dat\"),\n        copy(\"input.ini\"),\n    ]\n}\n</code></pre>"},{"location":"configuration/#parameter-dependent-execution","title":"Parameter-dependent execution","text":"<p>As a parametrized job runner, Grevling allows almost any step of the job running process to depend on the value of one or more parameters. As we have seen above, files can undergo template substitution, but that is not all. Most entries in the Grevling configuration file can be functions that accept parameters as input and return the necessary values.</p> <p>For example, assume we have an <code>adaptive</code> parameter as such:</p> <pre><code>{\n    parameters: {\n        adaptive: [true, false],\n    }\n}\n</code></pre> <p>Let us also assume that our command requires an input file that is different when <code>adaptive</code> is true as opposed to false, and let us also assume that this difference is great enough that we are not interested in using template substitution to solve the problem - or perhaps that the input file is binary, and thus template substitution will not work.</p> <p>Instead we could make <code>prefiles</code> a function that determines what file to use:</p> <pre><code>import \"grevling\" as { copy }\n\n{\n    prefiles: {|adaptive|} [\n        copy(\n            if adaptive\n                then \"input-adaptive.dat\"\n                else \"input-nonadaptive.dat\",\n            \"input.dat\"\n        ),\n    ]\n}\n</code></pre> <p>During job preparation, Grevling will call this function with the parameter <code>adaptive</code> as a keyword argument. The return value will then be used as the job preparation schema for that job instance. In this case, it indicates that either input-adaptive.dat or input-nonadaptive.dat should be copied to input.dat in the working directory, depending on the value of <code>adaptive</code>.</p> <p>Note that all parameters as well as TODO will be provided as keyword arguments. In Gold, it is not an error if a function is called with more keyword arguments than it accepts, thus the above will work even if more parameters are added: a function may accept only those it requires.</p> <p>All of the <code>prefiles</code>, <code>postfiles</code> and <code>script</code> keys support this mechanism. It can be used, for example, to allow command-line arguments to some commands to be parameter-dependent:</p> <pre><code>import \"grevling\" as { cmd }\n\n{\n    script: {|adaptive|} [\n        cmd([\n            \"some-command\",\n            if adaptive then \"--adaptive\" else \"--no-adaptive\",\n        ]),\n    ]\n}\n</code></pre> <p>or perhaps this, making use of Gold's advanced collection features.</p> <pre><code>import \"grevling\" as { cmd }\n\n{\n    script: {|adaptive|} [\n        cmd([\n            \"some-command\",\n            if adaptive: \"--adaptive\",\n        ]),\n    ]\n}\n</code></pre>"},{"location":"configuration/#extra-evaluation","title":"Extra evaluation","text":"<p>Often it is necessary to perform extra evalution of certain parameter-dependent quantities in a central location. For this purpose, Grevling offers the <code>evaluate</code> key, which should be a function of the parameters, and which returns an object of extra values. Those extra values can be used as input to other functions (such as <code>prefiles</code>, <code>postfiles</code> and <code>script</code>) - as if they were parameters, and they are also collected in the Grevling database as part of the evaluation context TODO.</p> <p>Consider for example:</p> <pre><code>{\n    parameters: {\n        degree: [1, 2, 3, 4, 5, 6],\n        meshsize: [1, 0.5, 0.25, 0.0125],\n        dimension: [1, 2, 3],\n    },\n}\n</code></pre> <p>In certain numerical simulations, a relevant quantity of interest might be the number of nodes in a mesh, which is</p> <pre><code>    ((1 / meshsize) + degree) ^ dimension\n</code></pre> <p>This formula can of course be replicated everywhere it might be needed:</p> <ul> <li>in templates</li> <li>in functions like <code>prefiles</code>, <code>postfiles</code> and <code>script</code></li> <li>when querying the database for results after running the job</li> </ul> <p>but it is tedious and error-prone to do so. Nor is it really a solution to parametrize the problem in terms of this quantity. To solve this, we can write:</p> <pre><code>{\n    parameters: {\n        degree: [1, 2, 3, 4, 5, 6],\n        meshsize: [1, 0.5, 0.25, 0.0125],\n        dimension: [1, 2, 3],\n    },\n    evaluate: {|degree, meshsize, dimension|} {\n        numnodes: ((1 / meshsize) + degree) ^ dimension,\n    },\n}\n</code></pre> <p>Now, <code>numnodes</code> will be available in all those contexts mentioned earlier on the same level as the parameters. For instance, you could write:</p> <pre><code>import \"grevling\" as { copy }\n\n{\n    prefiles: {|numnodes|}: [\n        copy(\"mesh.dat\", \"mesh-${nnodes}.dat\"),\n    ]\n}\n</code></pre>"}]}